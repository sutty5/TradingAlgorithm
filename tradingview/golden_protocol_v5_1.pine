//@version=6
strategy("Golden Protocol v5.1 [Einstein Personality]", overlay=true, initial_capital=100000, default_qty_type=strategy.fixed, default_qty_value=1, currency=currency.USD, max_labels_count=500, process_orders_on_close=true, calc_on_order_fills=true)

// -----------------------------------------------------------------------------
// ðŸ§  GOLDEN PROTOCOL v5.1 "EINSTEIN PERSONALITY"
// -----------------------------------------------------------------------------
// The "Einstein" update recognizes that ES and NQ have different "personalities".
// ES: The "Sniper". Requires Deep Wicks (>0.35), Low Vix (<4.0 ATR), Aggressive Defense (BE @ 0.5R).
// NQ: The "Beast". Requires Volatility (RVOL > 1.0), and Room to Run (No BE).

// --- INPUTS ---
grp_strat = "Strategy Settings"
use_date_filter = input.bool(true, "Use Date Filter", group=grp_strat)
start_date = input.time(timestamp("21 Sep 2025 00:00 +0000"), "Start Date", group=grp_strat)

grp_params = "Einstein Parameters"
t_entry = input.float(0.618, "Entry Fib", group=grp_params)
t_stop = input.float(1.0, "Stop Fib (Sweep)", group=grp_params)
t_target = input.float(0.0, "Target Fib (Impulse)", group=grp_params)

// --- SYMBOLS ---
// We need ES data to calculate Divergence if on NQ, and NQ if on ES.
// For simplicity, we ask user to select the "Other" asset.
sym_pair = input.symbol("CME_MINI:ES1!", "Correlation Pair", group="Data")

// --- ASSET DETECTION & PARAMETER SELECTION ---
// Auto-detect settings based on current chart symbol
is_nq =  str.contains(syminfo.ticker, "NQ") or str.contains(syminfo.ticker, "QQQ")
is_es =  str.contains(syminfo.ticker, "ES") or str.contains(syminfo.ticker, "SPY")

// Default to NQ settings if unknown
var float min_wick_ratio = 0.0
var float min_rvol = 0.0
var float max_atr = 0.0
var float be_trigger = 0.0

if is_es
    // ES PERSONALITY
    min_wick_ratio := 0.35
    min_rvol := 0.0
    max_atr := 4.0
    be_trigger := 0.5
else
    // NQ PERSONALITY (Default)
    min_wick_ratio := 0.0
    min_rvol := 1.0
    max_atr := 0.0 // Disabled
    be_trigger := 0.0 // Disabled

// --- DATA FETCHING ---
other_open = request.security(sym_pair, timeframe.period, open, lookahead=barmerge.lookahead_off)
other_close = request.security(sym_pair, timeframe.period, close, lookahead=barmerge.lookahead_off)

// --- INSTANT INDICATORS ---
// Wick Ratio
candle_range = high - low
body_top = math.max(open, close)
body_bottom = math.min(open, close)
wick_ratio_up = candle_range > 0 ? (high - body_top) / candle_range : 0
wick_ratio_down = candle_range > 0 ? (body_bottom - low) / candle_range : 0

// RVOL (20)
vol_ma = ta.sma(volume, 20)
rvol = vol_ma > 0 ? volume / vol_ma : 0

// ATR (14)
atr_val = ta.atr(14)

// --- HELPER FUNCTIONS ---
get_direction(o, c) =>
    c > o ? 1 : c < o ? -1 : 0

// --- STATE MANAGEMENT ---
var string state = "SCANNING" // SCANNING, PPI, SWEEP, PENDING, FILLED
var float ppi_high = na
var float ppi_low = na
var int ppi_other_dir = 0
var int candles_since_ppi = 0

// Sweep Info
var float sweep_extreme = na
var string sweep_type = na

// Trade Info (For Pending Orders)
var float pending_entry = na
var float pending_stop = na
var float pending_target = na

// Breakeven State
var bool be_active = false
var float active_entry = na
var float active_stop = na

// --- LOGIC ---

// 1. Calculate Directions
my_dir = get_direction(open, close)
other_dir = get_direction(other_open, other_close)

// 2. Blocked Hours (UTC)
utc_hour = hour(time, "UTC")
// Both use [8, 9, 18, 19]
is_blocked = (utc_hour == 8 or utc_hour == 9 or utc_hour == 18 or utc_hour == 19)

// 3. Date Filter
in_date_range = not use_date_filter or time >= start_date

// RESET if too much time passes without Sweep
if state == "PPI"
    candles_since_ppi += 1
    if candles_since_ppi > 12
        state := "SCANNING"

// -----------------------------------------------------------------------------
// STATE MACHINE
// -----------------------------------------------------------------------------

// STATE: SCANNING
if state == "SCANNING" and not is_blocked and in_date_range
    if my_dir != 0 and other_dir != 0 and my_dir != other_dir
        // Divergence found
        state := "PPI"
        ppi_high := high
        ppi_low := low
        ppi_other_dir := other_dir
        candles_since_ppi := 0

// STATE: PPI
if state == "PPI"
    // Short Sweep Check
    if high > ppi_high and close <= ppi_high
        // FILTER CHECK
        bool pass_filter = true
        if max_atr > 0 and atr_val > max_atr
            pass_filter := false
        if min_wick_ratio > 0 and wick_ratio_up < min_wick_ratio
            pass_filter := false
        if min_rvol > 0 and rvol < min_rvol
            pass_filter := false
            
        if pass_filter
            state := "SWEEP"
            sweep_extreme := high
            sweep_type := "SHORT"
    
    // Long Sweep Check
    else if low < ppi_low and close >= ppi_low
        // FILTER CHECK
        bool pass_filter = true
        if max_atr > 0 and atr_val > max_atr
            pass_filter := false
        if min_wick_ratio > 0 and wick_ratio_down < min_wick_ratio
            pass_filter := false
        if min_rvol > 0 and rvol < min_rvol
            pass_filter := false
            
        if pass_filter
            state := "SWEEP"
            sweep_extreme := low
            sweep_type := "LONG"

// STATE: SWEEP
if state == "SWEEP"
    candles_since_ppi += 1 
    
    // Invalidation
    if sweep_type == "SHORT" and close > sweep_extreme
        state := "SCANNING"
    else if sweep_type == "LONG" and close < sweep_extreme
        state := "SCANNING"
    // Timeout
    else if candles_since_ppi > 24
        state := "SCANNING"
    
    else if sweep_type == "SHORT"
        if close < ppi_low
            // BOS Confirmed
            fib_0 = low
            fib_1 = sweep_extreme
            fib_range = math.abs(fib_1 - fib_0)
            pending_entry := fib_0 + (fib_range * t_entry)
            pending_stop := fib_1
            pending_target := fib_0
            state := "PENDING"
            
    else if sweep_type == "LONG"
        if close > ppi_high
            // BOS Confirmed
            fib_0 = high
            fib_1 = sweep_extreme
            fib_range = math.abs(fib_1 - fib_0)
            pending_entry := fib_0 - (fib_range * t_entry) // Long entry below high
            pending_stop := fib_1
            pending_target := fib_0
            state := "PENDING"

// STATE: PENDING (Execution)
if state == "PENDING"
    if sweep_type == "SHORT"
        strategy.entry("Einstein Short", strategy.short, limit=pending_entry, comment="Short E" + str.tostring(t_entry))
        strategy.exit("Exit Short", "Einstein Short", stop=pending_stop, limit=pending_target)
        active_entry := pending_entry
        active_stop := pending_stop
        be_active := false
    else
        strategy.entry("Einstein Long", strategy.long, limit=pending_entry, comment="Long E" + str.tostring(t_entry))
        strategy.exit("Exit Long", "Einstein Long", stop=pending_stop, limit=pending_target)
        active_entry := pending_entry
        active_stop := pending_stop
        be_active := false

    state := "SCANNING" // Reset and look for next

// MANAGEMENT: BREAKEVEN
// If we are in a trade, check for BE logic
if strategy.opentrades > 0 and be_trigger > 0 and not be_active
    // Check if we hit trigger
    // For Short: Price drops below Entry - (Risk * Trigger)
    // For Long: Price rises above Entry + (Risk * Trigger)
    // Note: Pine Script doesn't give easy access to "Max Favorable Excursion" for open trade in real-time easily without tracking it manually.
    // simpler: If current close is favorable enough, update stop.
    
    // We rely on active_entry/stop variables we set on entry.
    // Warning: This only works for ONE active trade at a time.
    
    risk = math.abs(active_entry - active_stop)
    
    if strategy.position_size < 0 // Short
        trigger_price = active_entry - (risk * be_trigger)
        if low <= trigger_price // Hit trigger
            strategy.exit("Exit Short BE", "Einstein Short", stop=active_entry, limit=pending_target, comment_loss="BE")
            be_active := true
            
    else if strategy.position_size > 0 // Long
        trigger_price = active_entry + (risk * be_trigger)
        if high >= trigger_price // Hit trigger
            strategy.exit("Exit Long BE", "Einstein Long", stop=active_entry, limit=pending_target, comment_loss="BE")
            be_active := true


// -----------------------------------------------------------------------------
// VISUALS
// -----------------------------------------------------------------------------
var table info_table = table.new(position.top_right, 2, 6, border_width=1)
if barstate.islast
    table.cell(info_table, 0, 0, "MODE", bgcolor=color.black, text_color=color.white)
    table.cell(info_table, 1, 0, is_es ? "ES (Sniper)" : "NQ (Beast)", bgcolor=is_es ? color.blue : color.orange, text_color=color.black)
    
    table.cell(info_table, 0, 1, "RVOL", bgcolor=color.gray, text_color=color.white)
    col_rvol = rvol >= min_rvol ? color.green : color.red
    table.cell(info_table, 1, 1, str.tostring(rvol, "#.##"), bgcolor=col_rvol, text_color=color.black)

    table.cell(info_table, 0, 2, "Wick Ratio", bgcolor=color.gray, text_color=color.white)
    // Show Up if last bar green, Down if red
    wr = close > open ? wick_ratio_up : wick_ratio_down
    col_wr = wr >= min_wick_ratio ? color.green : color.red
    table.cell(info_table, 1, 2, str.tostring(wr, "#.##"), bgcolor=col_wr, text_color=color.black)
    
    table.cell(info_table, 0, 3, "ATR", bgcolor=color.gray, text_color=color.white)
    col_atr = (max_atr > 0 and atr_val > max_atr) ? color.red : color.green
    table.cell(info_table, 1, 3, str.tostring(atr_val, "#.##"), bgcolor=col_atr, text_color=color.black)
