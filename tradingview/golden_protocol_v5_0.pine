//@version=6
strategy("Golden Protocol v5.0 [Einstein Strategy]", overlay=true, initial_capital=50000, default_qty_type=strategy.fixed, default_qty_value=1, currency=currency.USD, max_labels_count=500)

// -----------------------------------------------------------------------------
// ðŸ§  GOLDEN PROTOCOL v5.0 "EINSTEIN PURE ALPHA" (STRATEGY EDITION)
// -----------------------------------------------------------------------------
// Asset: NQ Only (Short Only)
// Logic: Dual-Asset Divergence (PPI) -> Short Sweep -> BOS
// Execution: Limit Entry at 0.618 Fib
// -----------------------------------------------------------------------------

// --- INPUTS ---
grp_strat = "Strategy Settings"
use_date_filter = input.bool(true, "Use Date Filter", group=grp_strat)
start_date = input.time(timestamp("21 Sep 2025 00:00 +0000"), "Start Date", group=grp_strat)

grp_params = "Einstein Parameters"
t_entry = input.float(0.618, "Entry Fib", group=grp_params)
t_stop = input.float(1.0, "Stop Fib (Sweep)", group=grp_params)
t_target = input.float(0.0, "Target Fib (Impulse)", group=grp_params)

// --- SYMBOLS ---
// We need ES data to calculate Divergence
sym_es = input.symbol("CME_MINI:ES1!", "ES Symbol (for Correlation)", group="Data")

// --- DATA FETCHING ---
es_open = request.security(sym_es, timeframe.period, open)
es_close = request.security(sym_es, timeframe.period, close)

// --- HELPER FUNCTIONS ---
get_direction(o, c) =>
    c > o ? 1 : c < o ? -1 : 0

// --- STATE MANAGEMENT ---
var string state = "SCANNING" // SCANNING, PPI, SWEEP, PENDING, FILLED
var float ppi_high = na
var float ppi_low = na
var int ppi_nq_dir = 0
var int candles_since_ppi = 0

// Sweep Info
var float sweep_extreme = na
var string sweep_type = na

// Trade Info (For Pending Orders)
var float pending_entry = na
var float pending_stop = na
var float pending_target = na
var bool signal_fired = false

// --- LOGIC ---

// 1. Calculate Directions
nq_dir = get_direction(open, close)
es_dir = get_direction(es_open, es_close)

// 2. Blocked Hours (UTC)
utc_hour = hour(time, "UTC")
is_blocked = (utc_hour == 8 or utc_hour == 9 or utc_hour == 18 or utc_hour == 19)

// 3. Date Filter
in_date_range = not use_date_filter or time >= start_date

// RESET if too much time passes without Sweep
if state == "PPI"
    candles_since_ppi += 1
    if candles_since_ppi > 12
        state := "SCANNING"

// -----------------------------------------------------------------------------
// STATE MACHINE
// -----------------------------------------------------------------------------

// STATE: SCANNING
if state == "SCANNING" and not is_blocked and in_date_range
    if nq_dir != 0 and es_dir != 0 and nq_dir != es_dir
        // Divergence
        state := "PPI"
        ppi_high := high
        ppi_low := low
        ppi_nq_dir := nq_dir
        candles_since_ppi := 0

// STATE: PPI
if state == "PPI"
    if high > ppi_high and close <= ppi_high
        // Short Sweep
        state := "SWEEP"
        sweep_extreme := high
        sweep_type := "SHORT"

// STATE: SWEEP
if state == "SWEEP"
    candles_since_ppi += 1 // Use same counter or new? Let's use same for simplicity or reset it?
    // Actually, distinct counter is better.
    
    // Invalidation: If price closes ABOVE the Sweep High, it's not a sweep, it's a breakout.
    if close > sweep_extreme
        state := "SCANNING"
        
    // Timeout: If we don't get BOS within 12 bars of Sweep, give up.
    else if candles_since_ppi > 24 // Give it some room (12 for PPI + 12 for BOS)
        state := "SCANNING"
    
    else if sweep_type == "SHORT"
        if close < ppi_low
            // BOS Confirmed! Signal!
            // Calculate Fib Levels
            fib_0 = low // Impulse Low
            fib_1 = sweep_extreme // Sweep High (Stop)
            fib_range = math.abs(fib_1 - fib_0)
            
            pending_entry := fib_0 + (fib_range * t_entry)
            pending_stop := fib_1
            pending_target := fib_0
            
            signal_fired := true
            state := "PENDING" // Wait for fill

// STATE: PENDING (Execution)
if state == "PENDING"
    // Place Strategy Order
    // "Golden Short"
    strategy.entry("Einstein Short", strategy.short, limit=pending_entry, comment="Limit " + str.tostring(t_entry))
    strategy.exit("Exit Short", "Einstein Short", stop=pending_stop, limit=pending_target, comment_loss="SL", comment_profit="TP")
    
    // Reset state once we are IN trigger mode.
    // Pine Strategy execution handles the "Filling".
    // We just reset internal logic to look for *new* setups if we are flat?
    // Actually, simple logic: Reset to SCANNING immediately after submitting.
    // Pine will keep the order active until filled or cancelled.
    // For manual mirroring, we want to see the lines.
    
    state := "SCANNING"
    signal_fired := false // Consumed

// CANCEL logic?
// If price goes above stop before fill?
// strategy.cancel("Einstein Short") if high > pending_stop ...


// -----------------------------------------------------------------------------
// VISUALS & INFO PANEL
// -----------------------------------------------------------------------------

// Plot Stats Table for Manual Trading
var table info_table = table.new(position.top_right, 2, 5, border_width=1)

if barstate.islast
    table.cell(info_table, 0, 0, "Last Signal", bgcolor=color.gray, text_color=color.white)
    table.cell(info_table, 1, 0, "Price", bgcolor=color.gray, text_color=color.white)
    
    // Check if we have a position or pending order
    status_txt = strategy.position_size != 0 ? "IN TRADE" : "SCANNING"
    color_status = strategy.position_size != 0 ? color.blue : color.black
    
    if strategy.opentrades > 0
        // We are in a trade, show targets
        entry_p = strategy.opentrades.entry_price(strategy.opentrades - 1)
        // Note: Pine v6 doesn't easily expose dynamic TP/SL of open orders without tracking vars.
        // We'll show the last calculated pending values if they are recent.
        
    table.cell(info_table, 0, 1, "Status", bgcolor=color_status, text_color=color.white)
    table.cell(info_table, 1, 1, status_txt, bgcolor=color.white, text_color=color.black)

    table.cell(info_table, 0, 2, "Entry (0.618)", bgcolor=color.blue, text_color=color.white)
    table.cell(info_table, 1, 2, str.tostring(pending_entry, "#.##"), bgcolor=color.white, text_color=color.black)

    table.cell(info_table, 0, 3, "Stop (1.0)", bgcolor=color.red, text_color=color.white)
    table.cell(info_table, 1, 3, str.tostring(pending_stop, "#.##"), bgcolor=color.white, text_color=color.black)

    table.cell(info_table, 0, 4, "Target (0.0)", bgcolor=color.green, text_color=color.white)
    table.cell(info_table, 1, 4, str.tostring(pending_target, "#.##"), bgcolor=color.white, text_color=color.black)

// PPI Markers
plotshape(state == "PPI" and candles_since_ppi == 0, "PPI", shape.diamond, location.top, color.yellow, size=size.tiny)
plotshape(state == "SWEEP", "Sweep", shape.triangledown, location.abovebar, color.orange, size=size.tiny)

// -----------------------------------------------------------------------------
// DEBUGGING
// -----------------------------------------------------------------------------
var table debug_tbl = table.new(position.bottom_right, 2, 6, border_width=1)
if barstate.islast
    table.cell(debug_tbl, 0, 0, "State", bgcolor=color.gray)
    table.cell(debug_tbl, 1, 0, state, bgcolor=color.black, text_color=color.white)
    
    table.cell(debug_tbl, 0, 1, "NQ Dir", bgcolor=color.gray)
    table.cell(debug_tbl, 1, 1, str.tostring(nq_dir), bgcolor=color.black, text_color=color.white)
    
    table.cell(debug_tbl, 0, 2, "ES Dir", bgcolor=color.gray)
    table.cell(debug_tbl, 1, 2, str.tostring(es_dir), bgcolor=color.black, text_color=color.white)
    
    table.cell(debug_tbl, 0, 3, "Valid ES Data?", bgcolor=color.gray)
    table.cell(debug_tbl, 1, 3, str.tostring(not na(es_close)), bgcolor=not na(es_close) ? color.green : color.red)

