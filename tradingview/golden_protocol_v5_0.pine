//@version=6
indicator("Golden Protocol v5.0 [Einstein]", overlay=true, max_labels_count=500, max_bars_back=5000)

// -----------------------------------------------------------------------------
// ðŸ§  GOLDEN PROTOCOL v5.0 "EINSTEIN PURE ALPHA"
// -----------------------------------------------------------------------------
// Asset: NQ Only (Short Only)
// Logic: Dual-Asset Divergence (PPI) -> Short Sweep -> BOS
// -----------------------------------------------------------------------------

// --- INPUTS ---
grp_strat = "Strategy Settings"
use_date_filter = input.bool(true, "Use Date Filter", group=grp_strat)
start_date = input.time(timestamp("21 Sep 2025 00:00 +0000"), "Start Date", group=grp_strat)

grp_params = "Einstein Parameters"
t_entry = input.float(0.618, "Entry Fib", group=grp_params)
t_stop = input.float(1.0, "Stop Fib (Sweep)", group=grp_params)
t_target = input.float(0.0, "Target Fib (Impulse)", group=grp_params)

// --- SYMBOLS ---
// We need ES data to calculate Divergence
// Use "ES1!" for continuous contract
sym_es = input.symbol("CME_MINI:ES1!", "ES Symbol (for Correlation)", group="Data")

// --- DATA FETCHING ---
// Get ES data for the current timeframe
es_open = request.security(sym_es, timeframe.period, open)
es_close = request.security(sym_es, timeframe.period, close)

// --- HELPER FUNCTIONS ---
get_direction(o, c) =>
    c > o ? 1 : c < o ? -1 : 0

// --- STATE MANAGEMENT ---
// We use var variables to persist state across bars
var string state = "SCANNING" // SCANNING, PPI, SWEEP, PENDING, FILLED
var float ppi_high = na
var float ppi_low = na
var int ppi_nq_dir = 0
var int candles_since_ppi = 0

// Sweep Info
var float sweep_extreme = na
var string sweep_type = na

// Trade Info
var float trade_entry = na
var float trade_stop = na
var float trade_target = na
var line l_entry = na
var line l_stop = na
var line l_target = na

// --- LOGIC ---

// 1. Calculate Directions
nq_dir = get_direction(open, close)
es_dir = get_direction(es_open, es_close)

// 2. Blocked Hours (UTC)
// 08-09, 18-19
utc_hour = hour(time, "UTC")
is_blocked = (utc_hour == 8 or utc_hour == 9 or utc_hour == 18 or utc_hour == 19)

// RESET if too much time passes without Sweep
if state == "PPI"
    candles_since_ppi += 1
    if candles_since_ppi > 12
        state := "SCANNING"
        // label.new(bar_index, high, "PPI Expire", style=label.style_label_down, color=color.gray, size=size.tiny)

// -----------------------------------------------------------------------------
// STATE MACHINE
// -----------------------------------------------------------------------------

// STATE: SCANNING
// Look for Divergence (PPI)
if state == "SCANNING" and not is_blocked
    if nq_dir != 0 and es_dir != 0 and nq_dir != es_dir
        // Divergence Detected!
        state := "PPI"
        ppi_high := high
        ppi_low := low
        ppi_nq_dir := nq_dir
        candles_since_ppi := 0
        
        // Label PPI
        // label.new(bar_index, high, "PPI", color=color.yellow, style=label.style_label_down, size=size.tiny)

// STATE: PPI
// Look for SWEEP (Short Only for v5.0)
if state == "PPI"
    // Update PPI Range (Expanding logic? No, static initial PPI candle for v5.0 logic)
    // Actually, verification code used the initial PPI candle levels.
    
    // Check Short Sweep: Price goes ABOVE PPI High, but Closes BELOW PPI High??
    // Wait, verification logic: "Wick beyond + Close inside" OR just "Wick beyond"?
    // Logic: "Sweep: Price wicks beyond PPI high/low"
    // Let's stick to the Python verify logic: 
    // "if nq.high > self.setup['ppi_high'] and nq.close <= self.setup['ppi_high']"
    
    if high > ppi_high and close <= ppi_high
        // Valid Short Sweep
        state := "SWEEP"
        sweep_extreme := high // This becomes Stop Loss (Fib 1.0)
        sweep_type := "SHORT"
        
        // Visual
        // label.new(bar_index, high, "SWEEP", color=color.orange, style=label.style_label_down, size=size.tiny)

// STATE: SWEEP
// Look for BOS (Break of Structure)
// Short BOS: Close BELOW PPI Low
if state == "SWEEP"
    if sweep_type == "SHORT"
        if close < ppi_low
            // BOS Confirmed! Signal!
            state := "PENDING"
            
            // Calculate Levels
            // Impulse Leg = BOS Low (Fib 0.0) to Sweep High (Fib 1.0)
            // Wait, Python logic used "nq.low" of the BOS candle as Fib 0.
            fib_0 = low
            fib_1 = sweep_extreme
            fib_range = math.abs(fib_1 - fib_0)
            
            entry_price = fib_0 + (fib_range * t_entry)
            stop_price = fib_1
            target_price = fib_0
            
            // Draw Trade
            l_entry := line.new(bar_index, entry_price, bar_index + 5, entry_price, color=color.blue, width=2)
            l_stop := line.new(bar_index, stop_price, bar_index + 5, stop_price, color=color.red, width=2)
            l_target := line.new(bar_index, target_price, bar_index + 5, target_price, color=color.green, width=2)
            
            label.new(bar_index, high, "SHORT\nTarget: " + str.tostring(target_price, "#.##"), color=color.red, textcolor=color.white, style=label.style_label_down)
            
            alert("SHORT SIGNAL | Entry: " + str.tostring(entry_price) + " | Stop: " + str.tostring(stop_price) + " | Target: " + str.tostring(target_price), alert.freq_once_per_bar_close)
            
            // Reset state logically (in backtest we track fill, here we just signal)
            state := "SCANNING" 

// -----------------------------------------------------------------------------
// VISUALS
// -----------------------------------------------------------------------------
plotshape(state == "PPI" and candles_since_ppi == 0, "PPI Start", shape.diamond, location.top, color.yellow, size=size.tiny)

