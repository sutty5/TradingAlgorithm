// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© SuttyTrading

//@version=6
strategy("Golden Protocol v7.1 [GOD MODE]", overlay=true, initial_capital=1000000, default_qty_type=strategy.fixed, default_qty_value=1, currency=currency.USD, max_labels_count=500, margin_long=10, margin_short=10, calc_bars_count=5000)

// =============================================================================
// ðŸ† GOD MODE CONSTANTS
// =============================================================================
// The "Golden Trinity" (3 Verified Legs)
// 1. ES SHORT (2m) -> Sniper.
// 2. NQ LONG  (5m) -> Banker.
// 3. ES LONG  (5m) -> Optimizer (Extension Target).

// --- INPUTS ---
grp_gm = "God Mode (Auto-Tuner)"
grp_gen = "General"
grp_ris = "Risk Management"

use_auto   = input.bool(true, "âœ¨ Enable God Mode Auto-Tuner", group=grp_gm, tooltip="Automatically applies scientifically validated parameters based on Ticker & Timeframe.")
show_dash  = input.bool(true, "Show Dashboard", group=grp_gen)
show_fibs  = input.bool(true, "Show Trailing Fibs", group=grp_gen)
risk_reward= input.bool(true, "Show R:R Labels", group=grp_gen)

// Manual Overrides (Used if Auto is OFF or for unlabeled tickers)
i_fib_entry = input.float(0.5, "Fib Entry (Manual)", group=grp_gen)
i_fib_stop  = input.float(1.0, "Fib Stop (Manual)", group=grp_gen)
i_fib_target= input.float(0.0, "Fib Target (Manual)", group=grp_gen)
i_expiry    = input.int(10,   "Expiry Candles", group=grp_gen)

// =============================================================================
// âš™ï¸ CONFIGURATION LOGIC
// =============================================================================
// We define the specific parameters for each known leg.

var float c_fib_entry = i_fib_entry
var float c_fib_stop  = i_fib_stop
var float c_fib_target= i_fib_target
var int   c_expiry    = i_expiry
var float c_wick_min  = 0.0
var float c_atr_max   = 0.0
var bool  c_macro     = false
var string c_mode_name = "Manual"

// Helper to determine Ticker Root
// Helper to determine Ticker Root
is_nq = syminfo.ticker == "NQ" or syminfo.ticker == "NQ1!" or syminfo.ticker == "MNQ" or syminfo.ticker == "QQQ" or syminfo.root == "NQ" or syminfo.root == "MNQ"
is_es = syminfo.ticker == "ES" or syminfo.ticker == "ES1!" or syminfo.ticker == "MES" or syminfo.ticker == "SPY" or syminfo.root == "ES" or syminfo.root == "MES"

// Detect Timeframe (in minutes)
tf_mins = timeframe.multiplier / (timeframe.isseconds ? 60 : 1)

// AUTO-TUNER
if use_auto
    // -------------------------------------------------------------------------
    // 1. THE VALIDATOR (ES Short 2m)
    // -------------------------------------------------------------------------
    if is_es and tf_mins == 2
        c_mode_name := "ðŸ» ES Short (Validator)"
        c_fib_entry := 0.5
        c_fib_stop  := 1.0
        c_fib_target:= 0.0 // Impulse Low
        c_expiry    := 15
        c_wick_min  := 0.25
        c_atr_max   := 6.0
        c_macro     := true // Filter: Trade only below EMA

    // -------------------------------------------------------------------------
    // 2. THE OPTIMIZER (ES Long 5m)
    // -------------------------------------------------------------------------
    else if is_es and tf_mins == 5
        c_mode_name := "ðŸ‚ ES Long (Optimizer)"
        c_fib_entry := 0.5
        c_fib_stop  := 1.0
        c_fib_target:= 0.1 // ðŸŽ¯ EXTENSION TARGET
        c_expiry    := 10
        c_wick_min  := 0.5
        c_atr_max   := 0.0
        c_macro     := true // Filter: Trade only above EMA

    // -------------------------------------------------------------------------
    // 3. THE BANKER (NQ Long 5m)
    // -------------------------------------------------------------------------
    else if is_nq and tf_mins == 5
        c_mode_name := "ðŸ‚ NQ Long (Banker)"
        c_fib_entry := 0.5
        c_fib_stop  := 1.0
        c_fib_target:= 0.0 // Impulse High
        c_expiry    := 10
        c_wick_min  := 0.5
        c_atr_max   := 0.0
        c_macro     := true

    // -------------------------------------------------------------------------
    // FALLBACK / INACTIVE
    // -------------------------------------------------------------------------
    else
        c_mode_name := "âš ï¸ NO GOD MODE CONFIG"

// =============================================================================
// ðŸ§  CORE STRATEGY LOGIC
// =============================================================================

// 1. PPI (Price-Price Interaction)
// We need the "Other" ticker for divergence.
i_other_ticker = input.symbol("", "Override Comparison Ticker", group=grp_gen, tooltip="Leave empty to specific Auto-Detect (ES vs NQ).")

// Auto-Detect Logic
var string auto_other = "CME_MINI:ES1!"
if is_nq
    auto_other := "CME_MINI:ES1!"
else if is_es
    auto_other := "CME_MINI:NQ1!"

// Final Selection
other_ticker_id = i_other_ticker != "" ? i_other_ticker : auto_other

other_close = request.security(other_ticker_id, timeframe.period, close)
other_open  = request.security(other_ticker_id, timeframe.period, open)

my_green    = close > open
other_green = other_close > other_open

// Divergence: Colors do not match
ppi_signal = (my_green != other_green)

// PPI State
var float ppi_high = na
var float ppi_low  = na
var int   ppi_age  = 0

if ppi_signal
    ppi_high := high
    ppi_low  := low
    ppi_age  := 0
else
    ppi_age += 1

// 2. MACRO FILTER (200 EMA on Chart? Or 50 EMA on 1H? Original was 50 EMA on 1H)
// God Mode specs say "Macro Trend". Let's use 50 EMA on 1H as standard Proxy.
// Use 'barmerge.gaps_on' to prevent na repainting issues if desired, but gaps_off is standard for indicators.
ema_macro = request.security(syminfo.tickerid, "60", ta.ema(close, 50), lookahead=barmerge.lookahead_off)
filter_bull = not c_macro or close > ema_macro
filter_bear = not c_macro or close < ema_macro

// DEBUG: Filter Bypass & Labels
debug_mode = input.bool(false, "ðŸž Debug Mode (Show All Sweeps)", group=grp_gen)

if debug_mode
    c_wick_min := 0.0
    c_atr_max := 0.0
    c_macro := false // Bypass macro

// Helper: Debug Label
f_dbg_label(txt, y, color_) =>
    if debug_mode
        label.new(bar_index, y, txt, color=color_, style=label.style_label_down, textcolor=color.white, size=size.small)


// 3. SWEEP IDENTIFICATION
// Look for wicks beyond PPI High/Low that CLOSE inside.

// Helper: Wick Ratio
get_wick(o, c, h, l, dir) => 
    rng = h - l
    if rng == 0 
        0.0
    else 
        dir > 0 ? (h - math.max(o,c)) / rng : (math.min(o,c) - l) / rng

// Logic
is_sweep_bull = false
is_sweep_bear = false
var float sweep_level = na
var int sweep_age = 0

if ppi_age > 0 and ppi_age <= 12
    // BULL SWEEP (Sweep Low)
    if low < ppi_low and close > ppi_low
        wick = get_wick(open, close, high, low, -1)
        atr  = ta.atr(14)
        // Check Filters
        pass_wick = wick >= c_wick_min
        pass_atr  = (c_atr_max == 0 or atr <= c_atr_max)
        pass_macro= filter_bull
        
        // Debug
        if debug_mode and not (pass_wick and pass_atr and pass_macro)
            fail_reason = ""
            if not pass_wick 
                fail_reason += "Wick " + str.tostring(wick, "#.##") + " < " + str.tostring(c_wick_min) + "\n"
            if not pass_atr
                fail_reason += "ATR " + str.tostring(atr, "#.##") + " > " + str.tostring(c_atr_max) + "\n"
            if not pass_macro
                fail_reason += "Macro Fail\n"
            f_dbg_label("ðŸš« PRE-FILTER FAIL:\n" + fail_reason, low, color.orange)

        if pass_wick and pass_atr and pass_macro
            // Check Config Direction (God Mode Spec)
            is_valid_dir = false
            if use_auto
                if str.contains(c_mode_name, "Long")
                    is_valid_dir := true
            else
                is_valid_dir := true // Manual Mode takes all
            
            if is_valid_dir
                is_sweep_bull := true
                sweep_level := low
                sweep_age := 0
                if debug_mode
                    f_dbg_label("âœ… SWEEP ACCEPTED", low, color.green)
            else if debug_mode
                f_dbg_label("ðŸš« DIR FAIL (Mode: " + c_mode_name + ")", low, color.orange)

    // BEAR SWEEP (Sweep High)
    if high > ppi_high and close < ppi_high
        wick = get_wick(open, close, high, low, 1)
        atr  = ta.atr(14)
        
        pass_wick = wick >= c_wick_min
        pass_atr  = (c_atr_max == 0 or atr <= c_atr_max)
        pass_macro= filter_bear
        
        // Debug
        if debug_mode and not (pass_wick and pass_atr and pass_macro)
            fail_reason = ""
            if not pass_wick 
                fail_reason += "Wick " + str.tostring(wick, "#.##") + " < " + str.tostring(c_wick_min) + "\n"
            if not pass_atr
                fail_reason += "ATR " + str.tostring(atr, "#.##") + " > " + str.tostring(c_atr_max) + "\n"
            if not pass_macro
                fail_reason += "Macro Fail\n"
            f_dbg_label("ðŸš« PRE-FILTER FAIL:\n" + fail_reason, high, color.orange)
        
        if pass_wick and pass_atr and pass_macro
            // Direction Check
            is_valid_dir = false
            if use_auto
                if str.contains(c_mode_name, "Short")
                    is_valid_dir := true
            else
                is_valid_dir := true
                
            if is_valid_dir
                is_sweep_bear := true
                sweep_level := high
                sweep_age := 0
                if debug_mode
                    f_dbg_label("âœ… SWEEP ACCEPTED", high, color.green)
            else if debug_mode
                f_dbg_label("ðŸš« DIR FAIL (Mode: " + c_mode_name + ")", high, color.orange)

// 4. BOS (Break of Structure) & ENTRY
// We wait for a CLOSE beyond the opposite PPI level.

// States
var bool state_waiting_bos_bull = false
var bool state_waiting_bos_bear = false

// Reset on new Sweep
if is_sweep_bull
    state_waiting_bos_bull := true
    state_waiting_bos_bear := false 
    // Visual: Sweep Label
    if show_fibs
        label.new(bar_index, low, "ðŸ‚ SWEEP", style=label.style_label_up, color=color.green, textcolor=color.white, size=size.normal)

if is_sweep_bear
    state_waiting_bos_bear := true
    state_waiting_bos_bull := false
    // Visual: Sweep Label
    if show_fibs
        label.new(bar_index, high, "ðŸ» SWEEP", style=label.style_label_down, color=color.red, textcolor=color.white, size=size.normal)

// Trailing logic (Update Impulse while waiting)
var float impulse_level = na

if state_waiting_bos_bull
    // Update Impulse (High)
    impulse_level := math.max(nz(impulse_level, high), high)
    
    sweep_age += 1
    if sweep_age > c_expiry
        state_waiting_bos_bull := false

    // Check BOS (Close above PPI High)
    if close > ppi_high
        // EXECUTION LOGIC (MATCHES SPEC)
        // Visual: BOS Marker
        label.new(bar_index, high, "âš¡ BOS\nLONG", color=color.lime, style=label.style_label_down, textcolor=color.black, size=size.normal)
        
        range_val = impulse_level - sweep_level
        entry_px  = impulse_level - (range_val * c_fib_entry)
        stop_px   = sweep_level  
        target_px = impulse_level + (range_val * c_fib_target)
        
        strategy.entry("Long", strategy.long, limit=entry_px, comment="GodMode Long")
        strategy.exit("Exit L", "Long", stop=stop_px, limit=target_px, comment_loss="SL", comment_profit="TP")
        
        // Reset
        state_waiting_bos_bull := false
        
        alert("GO LONG: " + syminfo.ticker + " @ " + str.tostring(entry_px), alert.freq_once_per_bar)

if state_waiting_bos_bear
    // Update Impulse (Low)
    impulse_level := math.min(nz(impulse_level, low), low)
    
    sweep_age += 1
    if sweep_age > c_expiry
        state_waiting_bos_bear := false

    // Check BOS (Close below PPI Low)
    if close < ppi_low
        // EXECUTION LOGIC
        // Visual: BOS Marker
        label.new(bar_index, low, "âš¡ BOS\nSHORT", color=color.red, style=label.style_label_up, textcolor=color.white, size=size.normal)
        
        range_val = sweep_level - impulse_level
        entry_px  = impulse_level + (range_val * c_fib_entry)
        stop_px   = sweep_level 
        target_px = impulse_level - (range_val * c_fib_target)
        
        strategy.entry("Short", strategy.short, limit=entry_px, comment="GodMode Short")
        strategy.exit("Exit S", "Short", stop=stop_px, limit=target_px, comment_loss="SL", comment_profit="TP")
        
        // Reset
        state_waiting_bos_bear := false
        
        alert("GO SHORT: " + syminfo.ticker + " @ " + str.tostring(entry_px), alert.freq_once_per_bar)

// Plot Trailing Fibs (Ghost Lines) with Shading
// Only show if we are in waiting state

// =============================================================================
// ðŸŽ¨ ADVANCED VISUALS (Pro Fib Tool)
// =============================================================================

// We use 'var' lines/labels so we can update them live (no repainting, just moving).
var line l_base   = na
var line l_entry  = na
var line l_stop   = na
var line l_target = na

var label lb_base  = na
var label lb_entry = na
var label lb_stop  = na
var label lb_target= na

var box b_zone = na // The "Fill" Zone

// Colors (Pro Palette)
c_bull_main = #00E676 // Bright Teal/Green
c_bull_bg   = color.new(#00E676, 90)
c_bear_main = #FF5252 // Bright Red/Orange
c_bear_bg   = color.new(#FF5252, 90)
c_text      = color.white

// Helper to Update Lines REMOVED (Scope Issue). Logic Inlined below.

// EXECUTE VISUAL UPDATE
if show_fibs
    // 1. Calculate Coordinates
    bool active = false
    bool is_bull = true
    
    // Persist values for when we transition from Stalking -> Trading
    var float p_pivot = na
    var float p_entry = na
    var float p_stop  = na
    var float p_target= na
    var int   p_x1    = na
    var bool  p_is_bull = true

    if state_waiting_bos_bull
        active := true
        is_bull := true
        p_is_bull := true
        rng = impulse_level - sweep_level
        p_pivot := impulse_level
        p_entry := impulse_level - (rng * c_fib_entry)
        p_target:= impulse_level + (rng * c_fib_target)
        p_stop  := sweep_level
        p_x1    := bar_index - sweep_age

    else if state_waiting_bos_bear
        active := true
        is_bull := false
        p_is_bull := false
        rng = sweep_level - impulse_level
        p_pivot := impulse_level
        p_entry := impulse_level + (rng * c_fib_entry)
        p_target:= impulse_level - (rng * c_fib_target)
        p_stop  := sweep_level
        p_x1    := bar_index - sweep_age

    // KEEP ACTIVE IF IN TRADE (Using persisted values)
    if strategy.position_size != 0
        active := true
        is_bull := strategy.position_size > 0
    
    // Assign final values for drawing
    float y_pivot = p_pivot
    float y_entry = p_entry
    float y_stop  = p_stop
    float y_target= p_target
    int   x1    = p_x1
    
    // If we are in trade, force the direction to match position (sanity check)
    if strategy.position_size != 0
        is_bull := strategy.position_size > 0

    // 2. Clear Old Objects
    line.delete(l_base)
    line.delete(l_entry)
    line.delete(l_stop)
    line.delete(l_target)
    label.delete(lb_base)
    label.delete(lb_entry)
    label.delete(lb_stop)
    label.delete(lb_target)
    box.delete(b_zone)

    // 3. Draw New Objects
    if active
        // Color Scheme
        c_main = is_bull ? c_bull_main : c_bear_main
        c_bg   = is_bull ? c_bull_bg   : c_bear_bg
        
        // PIVOT (0.0)
        l_base := line.new(x1, y_pivot, bar_index + 5, y_pivot, color=color.gray, style=line.style_dotted)
        lb_base := label.new(bar_index + 5, y_pivot, "Avg (0.0)\n" + str.tostring(y_pivot, "#.##"), color=color(na), textcolor=color.gray, style=label.style_label_left, size=size.tiny)

        // ENTRY (0.5)
        l_entry := line.new(x1, y_entry, bar_index + 5, y_entry, color=c_main, width=2)
        lb_entry := label.new(bar_index + 5, y_entry, "ENTRY (0.5)\n" + str.tostring(y_entry, "#.##"), color=c_main, textcolor=color.black, style=label.style_label_left, size=size.small)

        // STOP (1.0)
        l_stop := line.new(x1, y_stop, bar_index + 5, y_stop, color=color.red, style=line.style_dashed)
        lb_stop := label.new(bar_index + 5, y_stop, "STOP (1.0)\n" + str.tostring(y_stop, "#.##"), color=color(na), textcolor=color.red, style=label.style_label_left, size=size.tiny)

        // TARGET
        l_target := line.new(x1, y_target, bar_index + 5, y_target, color=c_main, style=line.style_dashed)
        lb_target := label.new(bar_index + 5, y_target, "TARGET\n" + str.tostring(y_target, "#.##"), color=color(na), textcolor=c_main, style=label.style_label_left, size=size.tiny)

        // ZONE
        b_zone := box.new(x1, y_pivot, bar_index + 5, y_stop, border_color=color(na), bgcolor=c_bg)

// =============================================================================
// ðŸŽ¨ VISUALS
// =============================================================================

// Plot PPI with Enhanced Visibility (Diamonds)
plotshape(ppi_high, "PPI High", shape.diamond, location.absolute, color.new(color.red, 20), size=size.tiny, offset=0)
plotshape(ppi_low, "PPI Low", shape.diamond, location.absolute, color.new(color.green, 20), size=size.tiny, offset=0)

// Dashboard
var table dash = table.new(position.top_right, 2, 7, bgcolor=color.new(color.black, 40))
if show_dash and barstate.islast
    table.cell(dash, 0, 0, "GOD MODE v7.1", text_color=color.yellow, bgcolor=color.new(color.black, 0))
    table.cell(dash, 0, 1, "Status", text_color=color.white)
    table.cell(dash, 1, 1, c_mode_name, text_color=str.contains(c_mode_name, "âš ï¸") ? color.red : color.green)
    
    table.cell(dash, 0, 2, "PPI Pair", text_color=color.white)
    table.cell(dash, 1, 2, "vs " + str.replace_all(other_ticker_id, "CME_MINI:", ""), text_color=color.gray)

    table.cell(dash, 0, 3, "Win Rate", text_color=color.white)
    wr = strategy.wintrades / strategy.closedtrades * 100
    table.cell(dash, 1, 3, str.tostring(wr, "#.##") + "%", text_color=wr > 60 ? color.green : color.orange)
    
    table.cell(dash, 0, 4, "Net PnL", text_color=color.white)
    pnl = strategy.netprofit
    table.cell(dash, 1, 4, "$" + str.tostring(pnl, "#"), text_color=pnl > 0 ? color.green : color.red)

    table.cell(dash, 0, 5, "Total Trades", text_color=color.white)
    table.cell(dash, 1, 5, str.tostring(strategy.closedtrades), text_color=color.white)

// =============================================================================
// ðŸŽ“ TUTORIAL DASHBOARD (Active GPS)
// =============================================================================
show_tutor = input.bool(true, "Show Active Tutorial", group="Tutorial")

var table tbl_tutor = table.new(position.bottom_right, 1, 5, bgcolor=color.new(color.black, 20), border_width=1, border_color=color.gray)

if show_tutor and barstate.islast
    // 1. TIMEFRAME CHECK (God Mode Verification)
    tf_status = "âœ… CORRECT"
    tf_color  = color.green
    bool is_wrong = false

    if is_es and tf_mins != 2
        tf_status = "â›” WRONG TF! USE 2m"
        tf_color := color.red
        is_wrong := true
    else if is_nq and tf_mins != 5
        tf_status = "â›” WRONG TF! USE 5m"
        tf_color := color.red
        is_wrong := true

    if is_wrong
        label.new(bar_index, high, "âš ï¸ STOP TRADING âš ï¸\nWRONG TIMEFRAME\nSWITCH TO: " + (is_es ? "2 min" : "5 min"), color=color.new(color.red, 10), textcolor=color.white, style=label.style_label_down, size=size.huge)
    
    // 2. DETERMINE PHASE & INSTRUCTION
    string phase_txt = ""
    string instr_txt = ""
    color  phase_col = color.gray
    
    // PRIORITY 1: IN TRADE
    if strategy.position_size != 0
        phase_txt := strategy.position_size > 0 ? "ðŸ‚ LONG POSITION LIVE" : "ðŸ» SHORT POSITION LIVE"
        phase_col := strategy.position_size > 0 ? c_bull_main : c_bear_main
        instr_txt := "Monitor Position.\nStop Loss & Target are Auto-Set.\nYou may manually close to secure profit."
    
    // PRIORITY 2: STALKING (Waiting for BOS)
    else if state_waiting_bos_bull
        phase_txt := "ðŸ‘€ STALKING BULL SETUP"
        phase_col := c_bull_main
        instr_txt := "1. SWEEP CONFIRMED (Green Zone).\n2. WAIT for Candle CLOSE > Entry Line.\n3. Limit Order will Auto-Place."
    
    else if state_waiting_bos_bear
        phase_txt := "ðŸ‘€ STALKING BEAR SETUP"
        phase_col := c_bear_main
        instr_txt := "1. SWEEP CONFIRMED (Red Zone).\n2. WAIT for Candle CLOSE < Entry Line.\n3. Limit Order will Auto-Place."
        
    // PRIORITY 3: SCANNING (Idle)
    else
        phase_txt := "ðŸ“¡ SCANNING..."
        phase_col := color.gray
        instr_txt := "Looking for SWEEP of PPI Structure.\n(Wick beyond Pivot, Close Inside)."

    // DRAW TABLE
    // Header
    table.cell(tbl_tutor, 0, 0, "ðŸŽ“ GOD MODE TUTORIAL", bgcolor=color.new(color.blue, 40), text_color=color.white, text_size=size.normal)
    
    // Config Check
    table.cell(tbl_tutor, 0, 1, "CONFIG: " + syminfo.ticker + " (" + str.tostring(tf_mins) + "m)\n" + tf_status, bgcolor=is_wrong ? color.red : color.black, text_color=color.white, text_size=size.small)
    
    // Current Phase
    table.cell(tbl_tutor, 0, 2, "CURRENT STATE:\n" + phase_txt, bgcolor=color.new(phase_col, 80), text_color=color.white, text_size=size.normal)
    
    // Instructions
    table.cell(tbl_tutor, 0, 3, "ACTION REQUIRED:\n" + instr_txt, bgcolor=color.black, text_color=color.white, text_size=size.small, text_halign=text.align_left)
    
    // Legend
    table.cell(tbl_tutor, 0, 4, "LEEND: ðŸ‚=Bull | ðŸ»=Bear | ðŸŽ¯=Target | â›”=Stop", bgcolor=color.new(color.gray, 80), text_color=color.white, text_size=size.tiny)
