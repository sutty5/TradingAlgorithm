// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© SuttyTrading

//@version=6
strategy("Golden Protocol v7.1 [GOD MODE]", overlay=true, initial_capital=1000000, default_qty_type=strategy.fixed, default_qty_value=1, currency=currency.USD, max_labels_count=500, margin_long=10, margin_short=10)

// =============================================================================
// ðŸ† GOD MODE CONSTANTS
// =============================================================================
// The "Golden Trinity" (3 Verified Legs)
// 1. ES SHORT (2m) -> Sniper.
// 2. NQ LONG  (5m) -> Banker.
// 3. ES LONG  (5m) -> Optimizer (Extension Target).

// --- INPUTS ---
grp_gm = "God Mode (Auto-Tuner)"
grp_gen = "General"
grp_ris = "Risk Management"

use_auto   = input.bool(true, "âœ¨ Enable God Mode Auto-Tuner", group=grp_gm, tooltip="Automatically applies scientifically validated parameters based on Ticker & Timeframe.")
show_dash  = input.bool(true, "Show Dashboard", group=grp_gen)
show_fibs  = input.bool(true, "Show Trailing Fibs", group=grp_gen)
risk_reward= input.bool(true, "Show R:R Labels", group=grp_gen)

// Manual Overrides (Used if Auto is OFF or for unlabeled tickers)
i_fib_entry = input.float(0.5, "Fib Entry (Manual)", group=grp_gen)
i_fib_stop  = input.float(1.0, "Fib Stop (Manual)", group=grp_gen)
i_fib_target= input.float(0.0, "Fib Target (Manual)", group=grp_gen)
i_expiry    = input.int(10,   "Expiry Candles", group=grp_gen)

// =============================================================================
// âš™ï¸ CONFIGURATION LOGIC
// =============================================================================
// We define the specific parameters for each known leg.

var float c_fib_entry = i_fib_entry
var float c_fib_stop  = i_fib_stop
var float c_fib_target= i_fib_target
var int   c_expiry    = i_expiry
var float c_wick_min  = 0.0
var float c_atr_max   = 0.0
var bool  c_macro     = false
var string c_mode_name = "Manual"

// Helper to determine Ticker Root
// Helper to determine Ticker Root
is_nq = syminfo.ticker == "NQ" or syminfo.ticker == "NQ1!" or syminfo.ticker == "MNQ" or syminfo.ticker == "QQQ" or syminfo.root == "NQ" or syminfo.root == "MNQ"
is_es = syminfo.ticker == "ES" or syminfo.ticker == "ES1!" or syminfo.ticker == "MES" or syminfo.ticker == "SPY" or syminfo.root == "ES" or syminfo.root == "MES"

// Detect Timeframe (in minutes)
tf_mins = timeframe.multiplier / (timeframe.isseconds ? 60 : 1)

// AUTO-TUNER
if use_auto
    // -------------------------------------------------------------------------
    // 1. THE VALIDATOR (ES Short 2m)
    // -------------------------------------------------------------------------
    if is_es and tf_mins == 2
        c_mode_name := "ðŸ» ES Short (Validator)"
        c_fib_entry := 0.5
        c_fib_stop  := 1.0
        c_fib_target:= 0.0 // Impulse Low
        c_expiry    := 15
        c_wick_min  := 0.25
        c_atr_max   := 6.0
        c_macro     := true // Filter: Trade only below EMA

    // -------------------------------------------------------------------------
    // 2. THE OPTIMIZER (ES Long 5m)
    // -------------------------------------------------------------------------
    else if is_es and tf_mins == 5
        c_mode_name := "ðŸ‚ ES Long (Optimizer)"
        c_fib_entry := 0.5
        c_fib_stop  := 1.0
        c_fib_target:= 0.1 // ðŸŽ¯ EXTENSION TARGET
        c_expiry    := 10
        c_wick_min  := 0.5
        c_atr_max   := 0.0
        c_macro     := true // Filter: Trade only above EMA

    // -------------------------------------------------------------------------
    // 3. THE BANKER (NQ Long 5m)
    // -------------------------------------------------------------------------
    else if is_nq and tf_mins == 5
        c_mode_name := "ðŸ‚ NQ Long (Banker)"
        c_fib_entry := 0.5
        c_fib_stop  := 1.0
        c_fib_target:= 0.0 // Impulse High
        c_expiry    := 10
        c_wick_min  := 0.5
        c_atr_max   := 0.0
        c_macro     := true

    // -------------------------------------------------------------------------
    // FALLBACK / INACTIVE
    // -------------------------------------------------------------------------
    else
        c_mode_name := "âš ï¸ NO GOD MODE CONFIG"

// =============================================================================
// ðŸ§  CORE STRATEGY LOGIC
// =============================================================================

// 1. PPI (Price-Price Interaction)
// We need the "Other" ticker for divergence.
i_other_ticker = input.symbol("", "Override Comparison Ticker", group=grp_gen, tooltip="Leave empty to specific Auto-Detect (ES vs NQ).")

// Auto-Detect Logic
var string auto_other = "CME_MINI:ES1!"
if is_nq
    auto_other := "CME_MINI:ES1!"
else if is_es
    auto_other := "CME_MINI:NQ1!"

// Final Selection
other_ticker_id = i_other_ticker != "" ? i_other_ticker : auto_other

other_close = request.security(other_ticker_id, timeframe.period, close)
other_open  = request.security(other_ticker_id, timeframe.period, open)

my_green    = close > open
other_green = other_close > other_open

// Divergence: Colors do not match
ppi_signal = (my_green != other_green)

// PPI State
var float ppi_high = na
var float ppi_low  = na
var int   ppi_age  = 0

if ppi_signal
    ppi_high := high
    ppi_low  := low
    ppi_age  := 0
else
    ppi_age += 1

// 2. MACRO FILTER (200 EMA on Chart? Or 50 EMA on 1H? Original was 50 EMA on 1H)
// God Mode specs say "Macro Trend". Let's use 50 EMA on 1H as standard Proxy.
// Use 'barmerge.gaps_on' to prevent na repainting issues if desired, but gaps_off is standard for indicators.
ema_macro = request.security(syminfo.tickerid, "60", ta.ema(close, 50), lookahead=barmerge.lookahead_off)
filter_bull = not c_macro or close > ema_macro
filter_bear = not c_macro or close < ema_macro

// DEBUG: Filter Bypass & Labels
debug_mode = input.bool(false, "ðŸž Debug Mode (Show All Sweeps)", group=grp_gen)

if debug_mode
    c_wick_min := 0.0
    c_atr_max := 0.0
    c_macro := false // Bypass macro

// Helper: Debug Label
f_dbg_label(txt, y, color_) =>
    if debug_mode
        label.new(bar_index, y, txt, color=color_, style=label.style_label_down, textcolor=color.white, size=size.small)


// 3. SWEEP IDENTIFICATION
// Look for wicks beyond PPI High/Low that CLOSE inside.

// Helper: Wick Ratio
get_wick(o, c, h, l, dir) => 
    rng = h - l
    if rng == 0 
        0.0
    else 
        dir > 0 ? (h - math.max(o,c)) / rng : (math.min(o,c) - l) / rng

// Logic
is_sweep_bull = false
is_sweep_bear = false
var float sweep_level = na
var int sweep_age = 0

if ppi_age > 0 and ppi_age <= 12
    // BULL SWEEP (Sweep Low)
    if low < ppi_low and close > ppi_low
        wick = get_wick(open, close, high, low, -1)
        atr  = ta.atr(14)
        // Check Filters
        pass_wick = wick >= c_wick_min
        pass_atr  = (c_atr_max == 0 or atr <= c_atr_max)
        pass_macro= filter_bull
        
        // Debug
        if debug_mode and not (pass_wick and pass_atr and pass_macro)
            fail_reason = ""
            if not pass_wick 
                fail_reason += "Wick " + str.tostring(wick, "#.##") + " < " + str.tostring(c_wick_min) + "\n"
            if not pass_atr
                fail_reason += "ATR " + str.tostring(atr, "#.##") + " > " + str.tostring(c_atr_max) + "\n"
            if not pass_macro
                fail_reason += "Macro Fail\n"
            f_dbg_label("ðŸš« PRE-FILTER FAIL:\n" + fail_reason, low, color.orange)

        if pass_wick and pass_atr and pass_macro
            // Check Config Direction (God Mode Spec)
            is_valid_dir = false
            if use_auto
                if str.contains(c_mode_name, "Long")
                    is_valid_dir := true
            else
                is_valid_dir := true // Manual Mode takes all
            
            if is_valid_dir
                is_sweep_bull := true
                sweep_level := low
                sweep_age := 0
                if debug_mode
                    f_dbg_label("âœ… SWEEP ACCEPTED", low, color.green)
            else if debug_mode
                f_dbg_label("ðŸš« DIR FAIL (Mode: " + c_mode_name + ")", low, color.orange)

    // BEAR SWEEP (Sweep High)
    if high > ppi_high and close < ppi_high
        wick = get_wick(open, close, high, low, 1)
        atr  = ta.atr(14)
        
        pass_wick = wick >= c_wick_min
        pass_atr  = (c_atr_max == 0 or atr <= c_atr_max)
        pass_macro= filter_bear
        
        // Debug
        if debug_mode and not (pass_wick and pass_atr and pass_macro)
            fail_reason = ""
            if not pass_wick 
                fail_reason += "Wick " + str.tostring(wick, "#.##") + " < " + str.tostring(c_wick_min) + "\n"
            if not pass_atr
                fail_reason += "ATR " + str.tostring(atr, "#.##") + " > " + str.tostring(c_atr_max) + "\n"
            if not pass_macro
                fail_reason += "Macro Fail\n"
            f_dbg_label("ðŸš« PRE-FILTER FAIL:\n" + fail_reason, high, color.orange)
        
        if pass_wick and pass_atr and pass_macro
            // Direction Check
            is_valid_dir = false
            if use_auto
                if str.contains(c_mode_name, "Short")
                    is_valid_dir := true
            else
                is_valid_dir := true
                
            if is_valid_dir
                is_sweep_bear := true
                sweep_level := high
                sweep_age := 0
                if debug_mode
                    f_dbg_label("âœ… SWEEP ACCEPTED", high, color.green)
            else if debug_mode
                f_dbg_label("ðŸš« DIR FAIL (Mode: " + c_mode_name + ")", high, color.orange)

// 4. BOS (Break of Structure) & ENTRY
// We wait for a CLOSE beyond the opposite PPI level.

// States
var bool state_waiting_bos_bull = false
var bool state_waiting_bos_bear = false

// Reset on new Sweep
if is_sweep_bull
    state_waiting_bos_bull := true
    state_waiting_bos_bear := false 
    // Visual: Sweep Label
    if show_fibs
        label.new(bar_index, low, "ðŸ‚ SWEEP", style=label.style_label_up, color=color.green, textcolor=color.white, size=size.small)

if is_sweep_bear
    state_waiting_bos_bear := true
    state_waiting_bos_bull := false
    // Visual: Sweep Label
    if show_fibs
        label.new(bar_index, high, "ðŸ» SWEEP", style=label.style_label_down, color=color.red, textcolor=color.white, size=size.small)

// Trailing logic (Update Impulse while waiting)
var float impulse_level = na

if state_waiting_bos_bull
    // Update Impulse (High)
    impulse_level := math.max(nz(impulse_level, high), high)
    
    sweep_age += 1
    if sweep_age > c_expiry
        state_waiting_bos_bull := false

    // Check BOS (Close above PPI High)
    if close > ppi_high
        // EXECUTION LOGIC (MATCHES SPEC)
        range_val = impulse_level - sweep_level
        entry_px  = impulse_level - (range_val * c_fib_entry)
        stop_px   = sweep_level  
        target_px = impulse_level + (range_val * c_fib_target)
        
        strategy.entry("Long", strategy.long, limit=entry_px, comment="GodMode Long")
        strategy.exit("Exit L", "Long", stop=stop_px, limit=target_px, comment_loss="SL", comment_profit="TP")
        
        // Reset
        state_waiting_bos_bull := false
        
        alert("GO LONG: " + syminfo.ticker + " @ " + str.tostring(entry_px), alert.freq_once_per_bar)

if state_waiting_bos_bear
    // Update Impulse (Low)
    impulse_level := math.min(nz(impulse_level, low), low)
    
    sweep_age += 1
    if sweep_age > c_expiry
        state_waiting_bos_bear := false

    // Check BOS (Close below PPI Low)
    if close < ppi_low
        // EXECUTION LOGIC
        range_val = sweep_level - impulse_level
        entry_px  = impulse_level + (range_val * c_fib_entry)
        stop_px   = sweep_level 
        target_px = impulse_level - (range_val * c_fib_target)
        
        strategy.entry("Short", strategy.short, limit=entry_px, comment="GodMode Short")
        strategy.exit("Exit S", "Short", stop=stop_px, limit=target_px, comment_loss="SL", comment_profit="TP")
        
        // Reset
        state_waiting_bos_bear := false
        
        alert("GO SHORT: " + syminfo.ticker + " @ " + str.tostring(entry_px), alert.freq_once_per_bar)

// Plot Trailing Fibs (Ghost Lines) with Shading
// Only show if we are in waiting state

// =============================================================================
// ðŸŽ¨ ADVANCED VISUALS (Pro Fib Tool)
// =============================================================================

// We use 'var' lines/labels so we can update them live (no repainting, just moving).
var line l_base   = na
var line l_entry  = na
var line l_stop   = na
var line l_target = na

var label lb_base  = na
var label lb_entry = na
var label lb_stop  = na
var label lb_target= na

var box b_zone = na // The "Fill" Zone

// Colors (Pro Palette)
c_bull_main = #00E676 // Bright Teal/Green
c_bull_bg   = color.new(#00E676, 90)
c_bear_main = #FF5252 // Bright Red/Orange
c_bear_bg   = color.new(#FF5252, 90)
c_text      = color.white

// Helper to Update Lines
f_move_fib(active, is_bull, x1, y_pivot, y_entry, y_stop, y_target) =>
    if active
        // Determine Color
        c_main = is_bull ? c_bull_main : c_bear_main
        c_bg   = is_bull ? c_bull_bg   : c_bear_bg
        
        // 1. PIVOT (0.0)
        line.delete(l_base)
        l_base := line.new(x1, y_pivot, bar_index + 5, y_pivot, color=color.gray, style=line.style_dotted)
        label.delete(lb_base)
        lb_base := label.new(bar_index + 5, y_pivot, "Avg (0.0)\n" + str.tostring(y_pivot, "#.##"), color=color(na), textcolor=color.gray, style=label.style_label_left, size=size.tiny)

        // 2. ENTRY (0.5) - Emphasized
        line.delete(l_entry)
        l_entry := line.new(x1, y_entry, bar_index + 5, y_entry, color=c_main, width=2)
        label.delete(lb_entry)
        lb_entry := label.new(bar_index + 5, y_entry, "ENTRY (0.5)\n" + str.tostring(y_entry, "#.##"), color=c_main, textcolor=color.black, style=label.style_label_left, size=size.small)

        // 3. STOP (1.0)
        line.delete(l_stop)
        l_stop := line.new(x1, y_stop, bar_index + 5, y_stop, color=color.red, style=line.style_dashed)
        label.delete(lb_stop)
        lb_stop := label.new(bar_index + 5, y_stop, "STOP (1.0)\n" + str.tostring(y_stop, "#.##"), color=color(na), textcolor=color.red, style=label.style_label_left, size=size.tiny)

        // 4. TARGET (Extension)
        line.delete(l_target)
        l_target := line.new(x1, y_target, bar_index + 5, y_target, color=c_main, style=line.style_dashed)
        label.delete(lb_target)
        lb_target := label.new(bar_index + 5, y_target, "TARGET\n" + str.tostring(y_target, "#.##"), color=color(na), textcolor=c_main, style=label.style_label_left, size=size.tiny)

        // 5. ZONE (Box)
        box.delete(b_zone)
        b_zone := box.new(x1, y_pivot, bar_index + 5, y_stop, border_color=color(na), bgcolor=c_bg)
    
    else
        // Cleanup if inactive
        line.delete(l_base)
        line.delete(l_entry)
        line.delete(l_stop)
        line.delete(l_target)
        label.delete(lb_base)
        label.delete(lb_entry)
        label.delete(lb_stop)
        label.delete(lb_target)
        box.delete(b_zone)

// EXECUTE VISUAL UPDATE
if show_fibs
    if state_waiting_bos_bull // BULL UPDATE
        // Calc Levels
        rng = impulse_level - sweep_level
        l_en = impulse_level - (rng * c_fib_entry)
        l_tp = impulse_level + (rng * c_fib_target)
        // Sweep Tick Index? We don't track sweep index specifically, but we can anchor to 'bar_index - sweep_age'
        sweep_idx = bar_index - sweep_age
        f_move_fib(true, true, sweep_idx, impulse_level, l_en, sweep_level, l_tp)

    else if state_waiting_bos_bear // BEAR UPDATE
        rng = sweep_level - impulse_level
        l_en = impulse_level + (rng * c_fib_entry)
        l_tp = impulse_level - (rng * c_fib_target)
        sweep_idx = bar_index - sweep_age
        f_move_fib(true, false, sweep_idx, impulse_level, l_en, sweep_level, l_tp)
        
    else // HIDE
        f_move_fib(false, true, 0, 0, 0, 0, 0)

// Dashboard
var table dash = table.new(position.top_right, 2, 7, bgcolor=color.new(color.black, 40))
if show_dash and barstate.islast
    table.cell(dash, 0, 0, "GOD MODE v7.1", text_color=color.yellow, bgcolor=color.new(color.black, 0))
    table.cell(dash, 0, 1, "Status", text_color=color.white)
    table.cell(dash, 1, 1, c_mode_name, text_color=str.contains(c_mode_name, "âš ï¸") ? color.red : color.green)
    
    table.cell(dash, 0, 2, "PPI Pair", text_color=color.white)
    table.cell(dash, 1, 2, "vs " + str.replace_all(other_ticker_id, "CME_MINI:", ""), text_color=color.gray)

    table.cell(dash, 0, 3, "Win Rate", text_color=color.white)
    wr = strategy.wintrades / strategy.closedtrades * 100
    table.cell(dash, 1, 3, str.tostring(wr, "#.##") + "%", text_color=wr > 60 ? color.green : color.orange)
    
    table.cell(dash, 0, 4, "Net PnL", text_color=color.white)
    pnl = strategy.netprofit
    table.cell(dash, 1, 4, "$" + str.tostring(pnl, "#"), text_color=pnl > 0 ? color.green : color.red)

    table.cell(dash, 0, 5, "Total Trades", text_color=color.white)
    table.cell(dash, 1, 5, str.tostring(strategy.closedtrades), text_color=color.white)
